<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5 Essential LeetCode Patterns for Technical Interviews - The Hustler Dev</title>
    <meta name="description" content="Master these 5 essential LeetCode patterns to ace your technical interviews and improve your problem-solving skills.">
    <link rel="stylesheet" href="../styles.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        .visualization {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #4a6bdf;
            overflow-x: auto;
            text-align: center;
        }
        .mermaid {
            display: inline-block;
            margin: 0 auto;
        }
        .pseudocode {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
        }
        .pseudocode pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
            white-space: pre;
        }
        .pseudocode h4 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <a href="../index.html" class="back-link">← Back to Resources</a>
        </div>
    </header>

    <main>
        <article class="resource-article">
            <div class="container">
                <h1>5 Essential LeetCode Patterns for Technical Interviews</h1>
                <p class="article-intro">Mastering these five LeetCode patterns will help you solve a wide range of coding interview problems efficiently. Each pattern comes with practice problems to reinforce your understanding.</p>
                
                <div class="tool-list">
                    <div class="tool-item">
                        <h2>1. Two Pointers</h2>
                        <p>This pattern uses two pointers to traverse data structures, either moving in the same direction (fast/slow) or opposite directions (opposite ends).</p>
                        <div class="visualization">
                            <h4>Two Pointers (Opposite Ends)</h4>
                            <div class="mermaid">
                                graph TD
                                    A[Array: 2, 7, 11, 15] --> B[Left Pointer → 2]
                                    A --> C[Right Pointer → 15]
                                    D[Target: 9] --> E[2 + 15 = 17 > 9]
                                    E --> F[Move Right Pointer Left]
                                    F --> G[2 + 11 = 13 > 9]
                                    G --> H[Move Right Pointer Left]
                                    H --> I[2 + 7 = 9 ✓]
                            </div>
                        </div>
                        <div class="pseudocode">
                            <h4>Pseudocode Example: Two Sum II (Opposite Ends)</h4>
                            <pre>
function twoSum(numbers, target):
    left = 0
    right = length(numbers) - 1
    
    while left < right:
        current_sum = numbers[left] + numbers[right]
        if current_sum == target:
            return [left + 1, right + 1]  # 1-based index
        elif current_sum < target:
            left++
        else:
            right--
    return [-1, -1]  # No solution found
                            </pre>
                        </div>
                        <p><strong>Practice Problems:</strong> 
                            <a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank">167. Two Sum II</a>, 
                            <a href="https://leetcode.com/problems/3sum/" target="_blank">15. 3Sum</a>,
                            <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank">42. Trapping Rain Water</a>,
                            <a href="https://leetcode.com/problems/container-with-most-water/" target="_blank">11. Container With Most Water</a>,
                            <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank">3. Longest Substring Without Repeating Characters</a>
                        </p>
                    </div>
                    
                    <div class="tool-item">
                        <h2>2. Sliding Window</h2>
                        <p>Maintains a window of elements in an array/string, which can be either fixed or variable in size.</p>
                        <div class="visualization">
                            <h4>Sliding Window Example</h4>
                            <p>For the string 'abcabcbb', the sliding window expands when new unique characters are found and contracts when duplicates are encountered, keeping track of the maximum window size with all unique characters.</p>
                        </div>
                        <div class="pseudocode">
                            <h4>Pseudocode Example: Longest Substring Without Repeating Characters</h4>
                            <pre>
function lengthOfLongestSubstring(s):
    charSet = new Set()
    left = 0
    maxLength = 0
    
    for right in range(len(s)):
        while s[right] in charSet:
            charSet.remove(s[left])
            left++
        charSet.add(s[right])
        maxLength = max(maxLength, right - left + 1)
    
    return maxLength
                            </pre>
                        </div>
                        <p><strong>Practice Problems:</strong> 
                            <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank">3. Longest Substring Without Repeating Characters</a>,
                            <a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank">76. Minimum Window Substring</a>,
                            <a href="https://leetcode.com/problems/longest-repeating-character-replacement/" target="_blank">424. Longest Repeating Character Replacement</a>,
                            <a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank">209. Minimum Size Subarray Sum</a>,
                            <a href="https://leetcode.com/problems/max-consecutive-ones-iii/" target="_blank">1004. Max Consecutive Ones III</a>
                        </p>
                    </div>

                    <div class="tool-item">
                        <h2>3. Binary Search on Answer</h2>
                        <p>Applies binary search to find the optimal solution in a sorted search space.</p>
                        <div class="visualization">
                            <h4>Binary Search on Answer</h4>
                            <div class="mermaid">
                                graph TD
                                    A[Piles: 3,6,7,11, H=8] --> B[Search Space: 1 to 11]
                                    B --> C[Mid = 6: 1+1+2+2=6h ≤ 8]
                                    C --> D[Search 1-5]
                                    D --> E[Mid = 3: 1+2+3+4=10h > 8]
                                    E --> F[Search 4-5]
                                    F --> G[Mid = 4: 1+2+2+3=8h ≤ 8]
                                    G --> H[Minimum speed = 4]
                            </div>
                        </div>
                        <div class="pseudocode">
                            <h4>Pseudocode Example: Koko Eating Bananas</h4>
                            <pre>
function minEatingSpeed(piles, h):
    left = 1
    right = max(piles)
    result = right
    
    while left <= right:
        mid = left + (right - left) // 2
        hours = 0
        
        for pile in piles:
            hours += ceil(pile / mid)
            
        if hours <= h:
            result = min(result, mid)
            right = mid - 1
        else:
            left = mid + 1
            
    return result
                            </pre>
                        </div>
                        <p><strong>Practice Problems:</strong> 
                            <a href="https://leetcode.com/problems/koko-eating-bananas/" target="_blank">875. Koko Eating Bananas</a>,
                            <a href="https://leetcode.com/problems/split-array-largest-sum/" target="_blank">410. Split Array Largest Sum</a>,
                            <a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank">1011. Capacity To Ship Packages Within D Days</a>,
                            <a href="https://leetcode.com/problems/magnetic-force-between-two-balls/" target="_blank">1552. Magnetic Force Between Two Balls</a>,
                            <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank">4. Median of Two Sorted Arrays</a>
                        </p>
                    </div>

                    <div class="tool-item">
                        <h2>4. DFS + Backtracking</h2>
                        <p>Explores all possible solutions by trying different choices and undoing them if they don't work.</p>
                        <div class="visualization">
                            <h4>DFS + Backtracking (Subsets of [1,2,3])</h4>
                            <div style="text-align: left; font-family: monospace; white-space: pre; padding: 1em; background: #f8f9fa; border-radius: 4px;">
Start: []
  ├─ [1]
  │   ├─ [1,2]
  │   │   └─ [1,2,3]
  │   └─ [1,3]
  ├─ [2]
  │   └─ [2,3]
  └─ [3]

All Subsets:
[[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]
                            </div>
                        </div>
                        <div class="pseudocode">
                            <h4>Pseudocode Example: Subsets</h4>
                            <pre>
function subsets(nums):
    result = []
    
    def backtrack(start, current):
        result.append(current.copy())
        
        for i in range(start, len(nums)):
            # Include the current element
            current.append(nums[i])
            # Move to the next element
            backtrack(i + 1, current)
            # Backtrack (exclude the current element)
            current.pop()
    
    backtrack(0, [])
    return result
                            </pre>
                        </div>
                        <p><strong>Practice Problems:</strong> 
                            <a href="https://leetcode.com/problems/subsets/" target="_blank">78. Subsets</a>,
                            <a href="https://leetcode.com/problems/subsets-ii/" target="_blank">90. Subsets II</a>,
                            <a href="https://leetcode.com/problems/permutations/" target="_blank">46. Permutations</a>,
                            <a href="https://leetcode.com/problems/word-search/" target="_blank">79. Word Search</a>,
                            <a href="https://leetcode.com/problems/n-queens/" target="_blank">51. N-Queens</a>
                        </p>
                    </div>

                    <div class="tool-item">
                        <h2>5. Top-Down DP with Memoization</h2>
                        <p>Breaks down problems into smaller subproblems and stores their solutions to avoid redundant calculations.</p>
                        <div class="visualization">
                            <h4>DP Memoization Approach</h4>
                            <p>In the unique paths problem, we build a DP table where each cell (i,j) represents the number of ways to reach it from the start. Each cell's value is the sum of the cell above it and the cell to its left.</p>
                        </div>
                        <div class="pseudocode">
                            <h4>Pseudocode Example: Unique Paths</h4>
                            <pre>
function uniquePaths(m, n):
    memo = 2D array of size m x n, initialized with -1
    
    function dp(row, col):
        # Base cases
        if row == m - 1 and col == n - 1:
            return 1
        if row >= m or col >= n:
            return 0
            
        # Check if already computed
        if memo[row][col] != -1:
            return memo[row][col]
            
        # Recursive case: move right + move down
        memo[row][col] = dp(row + 1, col) + dp(row, col + 1)
        return memo[row][col]
    
    return dp(0, 0)
                            </pre>
                        </div>
                        <p><strong>Practice Problems:</strong> 
                            <a href="https://leetcode.com/problems/unique-paths/" target="_blank">62. Unique Paths</a>,
                            <a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank">1143. Longest Common Subsequence</a>,
                            <a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank">416. Partition Equal Subset Sum</a>,
                            <a href="https://leetcode.com/problems/target-sum/" target="_blank">494. Target Sum</a>,
                            <a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling/" target="_blank">1235. Maximum Profit in Job Scheduling</a>
                        </p>
                    </div>
                </div>
                
                <div class="closing-note">
                    <p><strong>Pro Tip:</strong> When practicing these patterns, focus on understanding the underlying concept rather than just memorizing solutions. Try to solve each problem multiple times until you can implement it without looking at the solution. Time yourself to improve your coding speed and efficiency.</p>
                </div>
            </div>
        </article>
    </main>

    <footer>
        <div class="container">
            <p class="footer-text">
                Follow <a href="https://www.instagram.com/thehustlerdev/" target="_blank" rel="noopener noreferrer">@thehustlerdev</a> on Instagram for more tips and resources.
            </p>
            <p class="footer-link">
                <a href="../index.html">← Back to Resources</a>
            </p>
        </div>
    </footer>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: true,
                theme: 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: false,
                    htmlLabels: true
                }
            });
        });
    </script>
    <style>
        .pseudocode pre {
            background: #f0f2f5;
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
        }
    </style>
</body>
</html>
